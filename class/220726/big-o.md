### 알고리즘의 시간 복잡도

> 좋은 알고리즘이란 무엇일까? == input을 넣은 후 output이 나오는 시간이 짧은 알고리즘!!

##### 알고리즘의 소요 시간 측정하기

1. 개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다르다. <br>환경에 영향을 받지 않을 객관적인 기준이 필요하다!!
2.  객관적인 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 살펴본다.<br>`기본연산의 총 횟수 == 알고리즘의 소요시간`
   - 성능을 측정할 때는 입력을 통일시킨다.
   - 가장 기본 연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정(= 시간 복잡도)



##### 시간복잡도

- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계\
- 단순하게 알고리즘의 수행 시간을 의미
  - 시간 복잡도가 높다 -> 느린 알고리즘
  - 시간복잡도가 낮다 -> 빠른 알고리늠



### 빅오 표기법

- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것
  - 최고차항만 남기고 계수와 상수 제거
  - 매 입력에 따라 정확한 수식을 구하는 것은 불필요
  - 정확한 수치보다는 증가율에 초점을 맞춘다

- 시간 복잡도 종류

| O(N)     | 단순 산술 계산(덧셈, 뺄셈, 곱셉, 나눗셈) | 단순계산 -> a + b, 100 * 200                          |
| -------- | ---------------------------------------- | ----------------------------------------------------- |
| O(logN)  | 크기 N인 리스트를 반절씩 순회/탐색       | 이진탐색(Binary Search)<br>분할정복(Divide & Conquer) |
| O(N)     | 크기 N인 리스트를 순회                   | 리스트 순회, 1중 for 문                               |
| O(NlogN) | 크기 N인 리스트를 반절씩 탐색 * 순회     | 높은 성능의 정렬<br>(Merge/Quick/Heap Sort)           |
| O(N^2)   | 크기 M, N인 2중 리스트를 순회            | 2중 리스트 순회, 2중 for 문                           |
| O(N^3)   | 3중 리스트를 순회                        | 3중 리스트 순회, 3중 for 문                           |
| O(2^N)   | 크기 N 집합의 부분 집합                  | 크기가 N인 집합의 부분 집합                           |
| O(N!)    | 크기 N 리스트의 순열                     | 크기가 N인 순열                                       |

- 예시

```python
# 방법 1: 1부터 n까지 일일이 더하기
def get_total(n):
  total = 0
  
  for i in range(1, n + 1):
    total += i
    
  return total

print(get_total(10))
# 55

print(get_total(100000000)
# 제한 시간 1초 초과
      
# 방법 2 : 가우스의 합 공식
def get_total(n):
      return (n * (n + 1)) // 2
      
print(get_total(10))
# 55

print(get_total(100000000)
# 50000000500000000
```

> 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈리는 포인트가 된다

- for문 안에 O(N)의 내장 함수를 사용했다면 사실상 이중 for문과 다를 것이 없음

